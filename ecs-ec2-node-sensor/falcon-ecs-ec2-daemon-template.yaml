AWSTemplateFormatVersion: 2010-09-09
Description: Sample template for launching Falcon Sensor for Linux container image as an ECS Daemon Service to a cluster
Parameters:
  ECSClusterName:
    Type: String
    Description: Cluster name to deploy Falcon Sensor for Linux as a Daemon Service
  CID:
    Type: String
    Description: CrowdStrike Customer ID (CID) value
  FalconImagePath:
    Type: String
    Description: The ECR image path including tag value for the Falcon Sensor for Linux container image
  SensorMemoryReservation:
    Type: String
    Description: Memory Reservation for the Falcon Sensor
    Default: 512
    AllowedValues:
      - 512
      - 1024
      - 2048
      - 3072
      - 4096
      - 5120
      - 6144
      - 7168
      - 8192
      - 9216
      - 10240
      - 11264
      - 12288
      - 13312
      - 14336
      - 15360
      - 16384
      - 17408
      - 18432
      - 19456
      - 20480
      - 21504
      - 22528
      - 23552
      - 24576
      - 25600
      - 26624
      - 27648
      - 28672
      - 29696
      - 30720

  APD:
    Type: String
    Default: ""
    Description: App Proxy Disable (APD)
  APH:
    Type: String
    Default: ""
    Description: App Proxy Host (APH)
  APP:
    Type: String
    Default: ""
    Description: App Proxy Port (APP)
  TRACE:
    Type: String
    Description: Set Trace Level
    Default: none
    AllowedValues:
      - none
      - err
      - warn
      - info
      - debug
  FEATURE:
    Type: String
    Default: ""
    Description: Sensor Feature Options
  TAGS:
    Type: String
    Default: "ecs-ec2-daemon"
    Description: Comma separated list of tags for sensor grouping
  PROVISIONINGTOKEN:
    Type: String
    Default: ""
    Description: Provisioning token value
  BACKEND:
    Type: String
    Default: bpf
    Description: Backend option, allowed values "kernel" and "bpf"
    AllowedValues:
      - bpf
      - kernel

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Mandatory Fields
        Parameters:
          - ECSClusterName
          - CID
          - FalconImagePath
          - SensorMemoryReservation
      - Label:
          default: Optional falconctl install options
        Parameters:
          - TAGS
          - PROVISIONINGTOKEN
          - TRACE
          - APD
          - APH
          - APP
          - FEATURE
          - BACKEND
  
Resources:
  NodeSensorTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      ContainerDefinitions:
        - Name: init-falconstore
          MemoryReservation: 128
          Image: !Ref FalconImagePath
          EntryPoint:
            - "/bin/bash"
          Command:
            - '-c' 
            - 'echo "Running /opt/CrowdStrike/falcon-daemonset-init -i"; /opt/CrowdStrike/falcon-daemonset-init -i'
          Essential: false
          Privileged: true
          ReadonlyRootFilesystem: false
          User: 0
          # LogConfiguration:
          #   LogDriver: awslogs
          #   Options:
          #     awslogs-group: !Sub "/aws/ecs/${ECSClusterName}/crowdstrike/falcon-daemon-service"
          #     awslogs-region: !Ref AWS::Region
          #     awslogs-stream-prefix: "node-init"
        - Name: crowdstrike-falcon-node-sensor
          Image: !Ref FalconImagePath
          Essential: true
          DependsOn:
            - ContainerName: init-falconstore
              Condition: COMPLETE
          Environment:
            - Name: FALCONCTL_OPT_CID
              Value: !Ref CID
            - Name: FALCONCTL_OPT_APD
              Value: !Ref APD
            - Name: FALCONCTL_OPT_APH
              Value: !Ref APH
            - Name: FALCONCTL_OPT_APP
              Value: !Ref APP
            - Name: FALCONCTL_OPT_TRACE
              Value: !Ref TRACE
            - Name: FALCONCTL_OPT_TAGS
              Value: !Ref TAGS
            - Name: FALCONCTL_OPT_FEATURE
              Value: !Ref FEATURE
            - Name: FALCONCTL_OPT_PROVISIONING_TOKEN
              Value: !Ref PROVISIONINGTOKEN
            - Name: FALCONCTL_OPT_BACKEND
              Value: !Ref BACKEND
          MemoryReservation: !Ref SensorMemoryReservation
          MountPoints:
            - ContainerPath: /opt/CrowdStrike/falconstore
              SourceVolume: falconstore
          Privileged: true
          ReadonlyRootFilesystem: false
          User: 0
          # LogConfiguration:
          #   LogDriver: awslogs
          #   Options:
          #     awslogs-group: !Sub "/aws/ecs/${ECSClusterName}/crowdstrike/falcon-daemon-service"
          #     awslogs-region: !Ref AWS::Region
          #     awslogs-stream-prefix: "node-sensor"
      Volumes:
        - Name: falconstore
          Host:
            SourcePath: /opt/CrowdStrike/falconstore
      NetworkMode: host
      IpcMode: host
      PidMode: host
      RuntimePlatform:
        OperatingSystemFamily: LINUX
      RequiresCompatibilities:
        - EC2

  FalconECSService:
    Type: AWS::ECS::Service
    DependsOn: NodeCleanupCustomResource
    Properties:
      Cluster: !Ref ECSClusterName
      SchedulingStrategy: DAEMON
      LaunchType: EC2
      ServiceName: crowdstrike-falcon-node-daemon
      TaskDefinition: !Ref NodeSensorTaskDefinition

  NodeCleanupTaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      ContainerDefinitions:
        - Name: cleanup-opt-crowdstrike
          Image: !Ref FalconImagePath
          MemoryReservation: 128
          EntryPoint:
            - "/bin/bash"
          Command:
            - '-c' 
            - 'echo "Running /opt/CrowdStrike/falcon-daemonset-init -u"; /opt/CrowdStrike/falcon-daemonset-init -u'
          Essential: false
          Privileged: true
          ReadonlyRootFilesystem: false
          User: 0
        - Name: cleanup-sleep
          Image: !Ref FalconImagePath
          Essential: true
          DependsOn:
            - ContainerName: cleanup-opt-crowdstrike
              Condition: COMPLETE
          MemoryReservation: 128
          EntryPoint:
            - "/bin/bash"
          Command:
            - '-c' 
            - 'sleep 10'
          Privileged: false
          ReadonlyRootFilesystem: true
      PidMode: host
      RuntimePlatform:
        OperatingSystemFamily: LINUX
      RequiresCompatibilities:
        - EC2

  
  NodeCleanupLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ECSCleanupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecs:ListContainerInstances
                  - ecs:DescribeContainerInstances
                  - ecs:RunTask
                  - ecs:PutAttributes
                Resource: "*"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"
    
  # Lambda Function for Cleanup after ECS Service Deletion
  NodeCleanupLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          import boto3
          import json
          import http.client
          import urllib.parse
          from botocore.exceptions import ClientError

          ecs = boto3.client("ecs")


          def handler(event, context):
              # Print incoming request event for debugging
              print("Received event:", json.dumps(event, indent=4))

              request_type = event["RequestType"]

              if request_type != "Delete":
                  print(f"Ignoring {request_type} event.")
                  send_response(
                      event,
                      context,
                      "SUCCESS",
                      "Non Delete event type receieved, no cleanup required.",
                  )
              elif request_type == "Delete":
                  print("Cleanup triggered after ECS Service deletion.")

                  # Get properties from event
                  cluster_name = event["ResourceProperties"].get("ClusterName")
                  task_definition = event["ResourceProperties"].get("TaskDefinition")

                  # Check if cluster still exists
                  try:
                      ecs.describe_clusters(clusters=[cluster_name])
                  except ClientError as e:
                      if e.response["Error"]["Code"] == "ClusterNotFoundException":
                          print(f"Cluster {cluster_name} not found.")
                          send_response(
                              event, context, "SUCCESS", "Cluster not found. No cleanup required."
                          )
                  else:
                      log_and_fail(event, context, e)

                  # List all container instances in the ECS cluster
                  try:
                      instance_arns = ecs.list_container_instances(cluster=cluster_name)[
                          "containerInstanceArns"
                      ]
                      # If no container instances are found, exit
                      if not instance_arns:
                          print("No container instances found in cluster. No cleanup necessary.")
                          send_response(
                              event,
                              context,
                              "SUCCESS",
                              "No container instances found. No cleanup necessary.",
                          )
                          return
                      num_instances = len(instance_arns)
                  except ClientError as e:
                      log_and_fail(event, context, e)



                  # Describe container instances
                  try:
                      container_details = ecs.describe_container_instances(
                          cluster=cluster_name, containerInstances=instance_arns
                      )["containerInstances"]
                  except ClientError as e:
                      log_and_fail(event, context, e)

                  # Collect running instance IDs and add custom attribute for cleanup job to execute
                  instance_ids = []
                  for container in container_details:
                      if container["status"] == "ACTIVE":
                          instance_id = container["ec2InstanceId"]
                          container_instance_arn = container["containerInstanceArn"]
                          instance_ids.append(instance_id)

                          # Register custom attribute for the instance ID
                          print(f"Registering custom attribute for instance ID: {instance_id}")
                          try:
                              response = ecs.put_attributes(
                                  cluster=cluster_name,
                                  attributes=[
                                      {
                                          'name': 'instanceId',
                                          'value': instance_id,
                                          'targetType': 'container-instance',
                                          'targetId': container_instance_arn,
                                      }
                                  ],
                              )
                              print(
                                  f"Successfully register attribute for instance {instance_id}."
                              )
                          except ClientError as e:
                              print(
                                  f"Failed to register attribute for instance {instance_id}: {e}"
                              )

                  # Log active instance IDs
                  print(f"Active instances in the cluster: {instance_ids}")

                  # Check if there are active instances to run task
                  if not instance_ids:
                      print("No active instances found in the cluster. No cleanup tasks to run.")
                      send_response(
                          event,
                          context,
                          "SUCCESS",
                          "No active instances found. No cleanup required.",
                      )
                      return

                  # Run the cleanup task on each instance
                  for instance_id in instance_ids:
                      try:
                          response = ecs.run_task(
                              cluster=cluster_name,
                              taskDefinition=task_definition,
                              count=1,
                              placementConstraints=[
                                  {
                                      "type": "memberOf",
                                      "expression": f"attribute:instanceId == {instance_id}",
                                  }
                              ],
                              launchType="EC2",
                          )
                          print(f"Clean task triggered on instance {instance_id}: {response}")
                      except ClientError as e:
                          print(f"Failed to run task on instance {instance_id}: {e}")
                          continue  # Log but continue to next instance

                  print(f"Cleanup tasks triggered on {len(instance_ids)} instances.")
                  send_response(
                      event,
                      context,
                      "SUCCESS",
                      f"Cleanup tasks triggered on {len(instance_ids)} instances.",
                  )
              else:
                  print(f"Unknown event type: {request_type}")
                  send_response(event, context, "FAILED", "Unknown request type.")


          def send_response(event, context, response_status, reason):
              response_body = json.dumps(
                  {
                      "Status": response_status,
                      "Reason": reason,
                      "PhysicalResourceId": context.log_stream_name,
                      "StackId": event["StackId"],
                      "RequestId": event["RequestId"],
                      "LogicalResourceId": event["LogicalResourceId"],
                  }
              )

              # Parse the response URL
              response_url = urllib.parse.urlparse(event["ResponseURL"])

              # Set up the connection to the pre-signed URL
              connection = http.client.HTTPSConnection(response_url.hostname)

              headers = {"Content-Type": "", "Content-Length": str(len(response_body))}

              # Send the PUT request to the pre-signed S3 URL
              connection.request(
                  "PUT",
                  response_url.path + "?" + response_url.query,
                  body=response_body,
                  headers=headers,
              )

              response = connection.getresponse()
              print(f"Response sent with status code {response.status}")
              connection.close()


          def log_and_fail(event, context, error):
              print(f"Response sent with status code {error}")
              send_response(event, context, "FAILED", str(error))


      Handler: index.handler
      Role: !GetAtt NodeCleanupLambdaExecutionRole.Arn
      Runtime: python3.12
      Timeout: 60

  # Custom Resource to Trigger Cleanup after ECS Service Deletion
  NodeCleanupCustomResource:
    Type: Custom::Cleanup
    Properties:
      ServiceToken: !GetAtt NodeCleanupLambdaFunction.Arn
      ClusterName: !Ref ECSClusterName
      TaskDefinition: !Ref NodeCleanupTaskDefinition

  # LogGroup:
  #   Type: AWS::Logs::LogGroup
  #   Properties:
  #     LogGroupName: !Sub "/aws/ecs/${ECSClusterName}/crowdstrike/falcon-daemon-service"
